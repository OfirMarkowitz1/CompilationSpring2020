%{
	#include <stdlib.h>
    #include <iostream>
    #include <stack>
    #include <unordered_map>
    
	#include "hw3_output.hpp"

    #include "Node.hpp"
    #include "NodeCaster.hpp"

    #include "TypeNodeFactory.hpp"
    #include "ExpressionNodeFactory.hpp"
    #include "CallNodeFactory.hpp"

    using namespace std;

	extern int yylineno;
	extern int yylex();
	void yyerror(const char*);

	NodeCaster nodeCaster;
	TypeNodeFactory typeNodeFactory;
	ExpressionNodeFactory expressionNodeFactory;
	CallNodeFactory callNodeFactory;

    // std::unordered_map<>;
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE BREAK CONTINUE COMMA ID NUM STRING LBRACE RBRACE LPAREN RPAREN SC
%nonassoc COND_WITHOUT_ELSE
%nonassoc ELSE
%right ASSIGN
%left OR
%left AND
%left EQUALITY
%nonassoc RELATIONAL
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT

%%

Program			:	Funcs {}
                ;
		
Funcs			: 	/* empty */    {}
				|	FuncDecl Funcs {}
                ;
		
FuncDecl		: 	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {}
                ;

RetType			:	Type { $$ = $1; }
				|	VOID { $$ = typeNodeFactory.createVoid(yylineno); }
                ;

Formals			:	/* empty */ {}
				|	FormalsList {}
                ;

FormalsList		:	FormalDecl {}
				|	FormalDecl COMMA FormalsList {}
                ;

FormalDecl 		:	Type ID {}
                ;
			
Statements		:	Statement {}
				|	Statements Statement {}
                ;
      
Statement	    :	LBRACE Statements RBRACE {}

				|	Type ID SC { 	TType varType = nodeCaster.castType($1)->getType();
									string varIdentifier = nodeCaster.castIdentifier($2)->getValue();
									/* Insert to symbol table */ }

				|	Type ID ASSIGN Exp SC {	TType varType = nodeCaster.castType($1)->getType();
											nodeCaster.castExpression($4)->assertAssignAllowed(varType);
											/* 	In case of type miss match - need to make sure line number 
												of expression is ok (maybe we need to use line number of the type?)	*/
											string varIdentifier = nodeCaster.castIdentifier($2)->getValue();
											/* Insert to symbol table */ }

				|	ID ASSIGN Exp SC { 	string varIdentifier = nodeCaster.castIdentifier($1)->getValue();
										/* 	varType - Infer type from symbol table 
											nodeCaster.castExpression($3)->assertAssignAllowed(varType); 
										   	In case of type miss match - need to make sure line number
										   	of expression is ok (maybe we need to use line number of the identifier?) */ }

				| 	Call SC {}
				|	RETURN SC {}
				|	RETURN Exp SC {}
				|	IF LPAREN Exp RPAREN Statement %prec COND_WITHOUT_ELSE {}
				| 	IF LPAREN Exp RPAREN Statement ELSE Statement {}
				|	WHILE LPAREN Exp RPAREN Statement %prec COND_WITHOUT_ELSE {}
				|	WHILE LPAREN Exp RPAREN Statement ELSE Statement {}
				|	BREAK SC {}
				|	CONTINUE SC {}
                ;
			
Call			: 	ID LPAREN ExpList RPAREN {	auto identifier = nodeCaster.castIdentifier($1);
												auto expressionList = nodeCaster.castExpressionList($3);
												$$ = callNodeFactory.create(T_INT, identifier); 
												/* Use identifier to infer function type!!! */ }

				| 	ID LPAREN RPAREN {	auto identifier = nodeCaster.castIdentifier($1);
										$$ = callNodeFactory.create(T_INT, identifier);
										/* Use identifier to infer function type!!! */ }
                ;
			
ExpList			: 	Exp {	auto firstExpression = nodeCaster.castExpression($1); 
							$$ = expressionNodeFactory.createList(firstExpression); }

				| 	Exp COMMA ExpList { auto expression = nodeCaster.castExpression($1);
										auto expressionList = nodeCaster.castExpressionList($3);
										expressionList->append(expression);
										$$ = expressionList; }
                ;
			
Type			: 	INT  { 	$$ = typeNodeFactory.createInt(yylineno);  }
				|	BYTE { 	$$ = typeNodeFactory.createByte(yylineno); }
				|	BOOL { 	$$ = typeNodeFactory.createBool(yylineno); }
                ;
			
Exp				:	LPAREN Exp RPAREN { $$ = $2; }

				|	Exp ADDITIVE Exp { 	auto lhs = nodeCaster.castExpression($1);
										auto rhs = nodeCaster.castExpression($3);
										$$ = expressionNodeFactory.createNumericBinop(lhs, rhs); }
				
				|	Exp MULTIPLICATIVE Exp { 	auto lhs = nodeCaster.castExpression($1);
												auto rhs = nodeCaster.castExpression($3);
												$$ = expressionNodeFactory.createNumericBinop(lhs, rhs); }

				|	ID { 	auto identifierNode = nodeCaster.castIdentifier($1);
							string identfierStr = identifierNode->getValue();
							/* Find identifier in symbol table to infer type */ }

				|	Call {	auto callNode = nodeCaster.castCall($1); 
							$$ = expressionNodeFactory.create(callNode->getLineNumber(), callNode->getType()); }

				|	NUM { $$ = expressionNodeFactory.createInt(yylineno); }

				|	NUM B { auto numNode = nodeCaster.castNum($1);
							numNode->assertByteValueNotTooLarge();
							$$ = expressionNodeFactory.createByte(numNode->getLineNumber()); }

				|	STRING { $$ = expressionNodeFactory.createString(yylineno);
							 /* 
							  * Though a string only suppose to appear in a print function call,
							  *	because of how the syntax is structured, I believe no additional 
							  *	check is required.
							  */ }

				|	TRUE { $$ = expressionNodeFactory.createBool(yylineno); }

				|	FALSE { $$ = expressionNodeFactory.createBool(yylineno); }

				|	NOT Exp { 	auto expression = nodeCaster.castExpression($2);
								expression->assertBool();
							  	$$ = expressionNodeFactory.createBool(expression->getLineNumber()); }

				|	Exp AND Exp { 	auto lhs = nodeCaster.castExpression($1);
									auto rhs = nodeCaster.castExpression($3);
									$$ = expressionNodeFactory.createLogicalBinop(lhs, rhs); }

				|	Exp OR Exp { 	auto lhs = nodeCaster.castExpression($1);
									auto rhs = nodeCaster.castExpression($3);
									$$ = expressionNodeFactory.createLogicalBinop(lhs, rhs); }

				|	Exp RELATIONAL Exp { 	auto lhs = nodeCaster.castExpression($1);
											auto rhs = nodeCaster.castExpression($3);
											$$ = expressionNodeFactory.createRelop(lhs, rhs); }								
				
				|	Exp EQUALITY Exp { 	auto lhs = nodeCaster.castExpression($1);
										auto rhs = nodeCaster.castExpression($3);
										$$ = expressionNodeFactory.createRelop(lhs, rhs); }
                ;
%%

int main()
{
	return yyparse();
}

void yyerror(const char* message)
{
	output::errorSyn(yylineno);
}
